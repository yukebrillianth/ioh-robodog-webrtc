<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Robot Dog — Live View</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }

        video {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: #000;
        }

        .overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #888;
            font-family: system-ui, sans-serif;
            font-size: 14px;
            text-align: center;
            display: none;
        }

        .overlay.visible {
            display: block;
        }

        .spinner {
            width: 32px;
            height: 32px;
            border: 3px solid #333;
            border-top-color: #0f0;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin: 0 auto 12px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Subtle live indicator when streaming */
        .live-dot {
            position: fixed;
            top: 12px;
            right: 12px;
            width: 10px;
            height: 10px;
            background: #e00;
            border-radius: 50%;
            animation: pulse 2s ease-in-out infinite;
            display: none;
        }

        .live-dot.active {
            display: block;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.3;
            }
        }
    </style>
</head>

<body>
    <video id="v" autoplay muted playsinline></video>
    <div class="overlay" id="msg">
        <div class="spinner"></div>
        Connecting video...
    </div>
    <div class="live-dot" id="liveDot"></div>
    <script>
        const video = document.getElementById('v');
        const msg = document.getElementById('msg');
        const liveDot = document.getElementById('liveDot');
        let ws, pc, statsTimer, abrTimer;

        // ─── Config ──────────────────────────────────────────────────
        const params = new URLSearchParams(window.location.search);
        const wsPort = params.get('port') || '8080';
        const wsHost = params.get('host') || window.location.hostname || 'localhost';
        const wsProto = window.location.protocol === 'https:' ? 'wss' : 'ws';
        const wsUrl = params.get('ws') || `${wsProto}://${wsHost}:${wsPort}`;

        let iceServers = null;

        // ─── ABR Config (tuned for Surabaya → Barcelona ~250ms RTT) ─
        const ABR = {
            min: 300,           // kbps floor
            max: 2000,          // kbps ceiling
            start: 1200,        // start conservative for international
            rttHigh: 250,       // ms — reduce bitrate (Surabaya→Barcelona normal)
            rttCritical: 400,   // ms — aggressive reduce
            rttLow: 150,        // ms — safe to increase
            lossThreshold: 3,   // packets/interval triggers reduction
            stableCycles: 5,    // cycles before increasing
        };
        let abrBitrate = ABR.start;
        let prevLost = 0;
        let stableCount = 0;

        // ─── Connect ─────────────────────────────────────────────────
        function connect() {
            msg.classList.add('visible');
            liveDot.classList.remove('active');

            try { ws = new WebSocket(wsUrl); }
            catch (e) { retry(); return; }

            ws.onopen = () => { };
            ws.onclose = () => { cleanup(); retry(); };
            ws.onerror = () => { };
            ws.onmessage = async (e) => {
                const m = JSON.parse(e.data);
                switch (m.type) {
                    case 'welcome':
                        iceServers = m.iceServers || null;
                        initPC();
                        break;
                    case 'offer':
                        if (!pc) break;
                        await pc.setRemoteDescription(new RTCSessionDescription({ type: 'offer', sdp: m.sdp }));
                        const answer = await pc.createAnswer();
                        await pc.setLocalDescription(answer);
                        ws.send(JSON.stringify({ type: 'answer', sdp: answer.sdp }));
                        break;
                    case 'candidate':
                        if (pc && m.data) {
                            try { await pc.addIceCandidate(new RTCIceCandidate(m.data)); } catch (_) { }
                        }
                        break;
                }
            };
        }

        // ─── Peer Connection ─────────────────────────────────────────
        function initPC() {
            const hasTurn = iceServers && iceServers.some(s => s.urls && String(s.urls).includes('turn:'));
            pc = new RTCPeerConnection({
                iceServers: iceServers || [{ urls: 'stun:stun.cloudflare.com:3478' }],
                iceTransportPolicy: hasTurn ? 'relay' : 'all',
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require'
            });

            // Connection timeout — 8s for international relay
            const timeout = setTimeout(() => {
                if (pc && pc.connectionState !== 'connected') {
                    console.warn('Connection timeout');
                    cleanup(); retry();
                }
            }, 8000);

            pc.ontrack = (e) => {
                clearTimeout(timeout);
                video.srcObject = e.streams[0] || new MediaStream([e.track]);
                video.play().catch(() => { });
                msg.classList.remove('visible');
                liveDot.classList.add('active');
                startABR();
            };

            pc.onicecandidate = (e) => {
                if (e.candidate && ws && ws.readyState === 1) {
                    ws.send(JSON.stringify({
                        type: 'candidate',
                        data: {
                            candidate: e.candidate.candidate,
                            sdpMid: e.candidate.sdpMid,
                            sdpMLineIndex: e.candidate.sdpMLineIndex
                        }
                    }));
                }
            };

            pc.onconnectionstatechange = () => {
                if (pc.connectionState === 'connected') {
                    clearTimeout(timeout);
                }
                if (pc.connectionState === 'failed' || pc.connectionState === 'closed') {
                    clearTimeout(timeout);
                    cleanup(); retry();
                }
                // Handle temporary disconnect (network blip) — wait 5s before giving up
                if (pc.connectionState === 'disconnected') {
                    setTimeout(() => {
                        if (pc && pc.connectionState === 'disconnected') {
                            cleanup(); retry();
                        }
                    }, 5000);
                }
            };

            pc.oniceconnectionstatechange = () => {
                if (pc && pc.iceConnectionState === 'failed') {
                    cleanup(); retry();
                }
            };
        }

        // ─── ABR Engine (FPS-driven) ─────────────────────────────────
        let prevFrames = 0;
        let prevAbrTs = 0;

        function startABR() {
            stopABR();
            prevLost = 0;
            prevFrames = 0;
            prevAbrTs = 0;
            stableCount = 0;
            abrBitrate = ABR.start;

            abrTimer = setInterval(async () => {
                if (!pc || pc.connectionState !== 'connected') return;

                let rtt = 0, lostDelta = 0, fps = -1;
                const stats = await pc.getStats();
                stats.forEach(r => {
                    if (r.type === 'candidate-pair' && r.state === 'succeeded' && r.currentRoundTripTime) {
                        rtt = r.currentRoundTripTime * 1000;
                    }
                    if (r.type === 'inbound-rtp' && r.kind === 'video') {
                        // Use framesPerSecond directly if available
                        if (r.framesPerSecond !== undefined) {
                            fps = r.framesPerSecond;
                        } else if (r.framesDecoded !== undefined) {
                            // Calculate FPS from decoded frames delta
                            const now = r.timestamp;
                            if (prevAbrTs > 0) {
                                const dt = (now - prevAbrTs) / 1000;
                                if (dt > 0) fps = (r.framesDecoded - prevFrames) / dt;
                            }
                            prevFrames = r.framesDecoded;
                            prevAbrTs = r.timestamp;
                        }
                        lostDelta = (r.packetsLost || 0) - prevLost;
                        prevLost = r.packetsLost || 0;
                    }
                });

                let changed = false;

                // PRIMARY: FPS-based detection (most direct congestion signal)
                if (fps >= 0 && fps < 10) {
                    // Critical FPS drop — slash bitrate 50%
                    abrBitrate = Math.max(ABR.min, Math.floor(abrBitrate * 0.5));
                    stableCount = 0;
                    changed = true;
                } else if (fps >= 0 && fps < 20) {
                    // Low FPS — reduce 30%
                    abrBitrate = Math.max(ABR.min, Math.floor(abrBitrate * 0.7));
                    stableCount = 0;
                    changed = true;
                }
                // SECONDARY: RTT/loss based
                else if (rtt > ABR.rttCritical || lostDelta > ABR.lossThreshold * 2) {
                    abrBitrate = Math.max(ABR.min, Math.floor(abrBitrate * 0.5));
                    stableCount = 0;
                    changed = true;
                } else if (rtt > ABR.rttHigh || lostDelta > ABR.lossThreshold) {
                    abrBitrate = Math.max(ABR.min, Math.floor(abrBitrate * 0.75));
                    stableCount = 0;
                    changed = true;
                }
                // RAMP UP: only when FPS is healthy AND network is good
                else if (fps >= 24 && rtt > 0 && rtt < ABR.rttLow && lostDelta <= 0) {
                    stableCount++;
                    if (stableCount >= ABR.stableCycles && abrBitrate < ABR.max) {
                        abrBitrate = Math.min(ABR.max, Math.floor(abrBitrate * 1.1));
                        stableCount = 0;
                        changed = true;
                    }
                } else {
                    stableCount = 0;
                }

                if (changed && ws && ws.readyState === 1) {
                    ws.send(JSON.stringify({ type: 'set_bitrate', bitrate_kbps: abrBitrate }));
                }
            }, 2000);
        }

        function stopABR() {
            if (abrTimer) { clearInterval(abrTimer); abrTimer = null; }
        }

        // ─── Cleanup & Retry ─────────────────────────────────────────
        function cleanup() {
            stopABR();
            liveDot.classList.remove('active');
            if (pc) { pc.close(); pc = null; }
            if (ws) { ws.onclose = null; ws.close(); ws = null; }
            video.srcObject = null;
        }

        function retry() {
            msg.classList.add('visible');
            setTimeout(connect, 2000);
        }

        // Keepalive ping every 5s (aggressive for tunnel stability)
        setInterval(() => {
            if (ws && ws.readyState === 1) ws.send(JSON.stringify({ type: 'ping' }));
        }, 5000);

        // Visibility change — reconnect when tab becomes visible again
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible' && (!pc || pc.connectionState !== 'connected')) {
                cleanup(); connect();
            }
        });

        connect();
    </script>
</body>

</html>